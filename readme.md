# Jet
## Реактивная javascript библиотека проектирования пользовательских веб-интерфейсов

> Не все алгоритмы, заложеные в механиках были полностью протестированы. 
> Ядро в стадии обкатки, держите это в уме и используйте Jet только по назначению!
> В качестве сборочного модуля используется [ESBuild](https://github.com/evanw/esbuild). Стабильная работа шаблонов гарантируется только с ним.

![иногда ещё помпажит](https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/JUMO_004_Jet_Propelled_Engine_GPN-2000-000369.jpg/1280px-JUMO_004_Jet_Propelled_Engine_GPN-2000-000369.jpg)


### Пролог и идея
История библиотеки берёт своё начало с необходимости описания толстого клиента виджета конструктора формы опросов со сложными конфигурациями и механиками.
Но сновная сложность заключалась в том, что проект виджета в одном из дочерних проектов крутится в окружении старой сборки chromium в 1C, из-за чего использование современных фреймворков оказалось слишком большим риском. Тогда было задумано написать свой, лёгкий, простой, быстрый и стабильный движок проектирования интерфейсов, способный запустить абстрактный реактивный компонент в относительно древних браузерных клиентах.
API библиотеки Jet, как и сама библиотека, не велики. Jet нельзя назвать декларативной в полном смысле этого слова. Остальных, вообще-то, тоже, но Jet ещё более императивен. Во-первых, его жизненный цикл управляется наполовину публичными методами, как, например, и в "декларативном" react, setState вызывает автоматическое обновление, но с уже вложенными под капот оптимизациями. Этот классический state driven подразумевает и создание, и удаление, и патчинг.
Но на удаление, как и создание виртуальных узлов, можно повлиять императивно, без посредничества объектов состояний, как это реализовано в других реактивных фреймворках.

Таким образом можно императивно управлять виртуальным деревом, не влияя на состояние данных напрямую. Это облегчает создание модальных, диалоговых окон, уведомлений, форм и любого сложного интерактива в принципе.

Управление данными обеспечено через props и eventBus.

- Props является чистым объектом данных, забранным по Rest API. С его помощью данные спускаются вниз по виртуальному дереву
- EventBus - хранилище сигнальных функций компонентов. С его помощью данные можно передавать в любое место приложения, собирая новые состояния из чего угодно для чего угодно.

### Назначение
Jet рекомендуется использовать для небольших внутренних виджетов и клиентов, независимых RestApi компонентов итп. Проектировать на нём сложную распределённую систему не рекомендуется, по крайней мере до тех пор, пока не будет глубоко интегрированное History Api.
Также рекомендуется для разработки клиентов Geogocoding Information Systems (GIS), поскольку в них сложносоставные события и их аргументы, а не flux store, часто являются первичным и единственным актуальным источником данных.

### Шаблонизация
Библиотека использует только одну зависимость - старый добрый [Mustache](https://github.com/janl/mustache.js), работает она с шаблонами через dependency injection как строки.
Очерь рекомендуется ознакомиться с документацией mustache для понимания процесса рендера списков элементов и понимания сути механизма их правильного обновления.
Шаблонизация поддерживается в ESBuild через специальный флаг в параметрах. В доках mustache этого не найдёте.

### Комбинация state and event driven подходов
 В библиотеке используется комбинированный подход state + event driven - она является антиподом flux-подхода. Её идеология в том, что любая интерактивная часть сценариев, влекущих за собой какие-то эффекты в пользовательском интерфейсе - это события, не только изначально, но и на всём стэке виртуального дерева компонентов.
 Именно с перехвата события начинается история взаимодействия со сценарием в любой state driven библиотеке, и на нём же событие, как правило и затухает. Далее данные как правило следуют в store или меняют текущее состояние. Но в любой современной библиотеке, поддерживающей в своей основе чистый state driven development встаёт ребром вопрос передачи данных и реакции на них вверх по дереву - в родительские узлы. В react для этого добавили redux, позже появился context api, которым, если умело пользоваться и много писать, можно обойтись и собрать быстрый рабочий интерфейс. Во Vue добавили Vuex, который как любой другой flux много весит и много ест.
 Поэтому способ передачи данных в Jet - самая главная фича и его основное отличие от других библиотек. В него встроен EventBus, который хранит в себе карты функций. Любой компонент может подписаться на любой компонент и получать любые данные от любого компонента к любому компоненту, при этом может не затрагивать вообще никакие состояния, или затрагивать их императивно, через методы (как бы наоборот).
 Поэтому парадигма мышления в Jet будет сперва несколько непривычна. Вполне нормально будет увидеть перехват события, который передаёт данные в EventBus событие глобального уровня, меняя или не меняя локальный стейт - по ситуации. Можно создавать целые цепочки событий и перенаправлять данные сквозь функции, точечно производя изменения от чего угодно на что угодно.
 
 ### Очень мало кода
 Все механики уместились в одном абстрактном классе, не превышающем размеры приличного.  
 Любой middle+ frontend dev может открыть начинку и понять что происходит - ничего сложного здесь нет, в отличие от сложных механик Vue, React или, боже упаси, Mobx.
 Также тут нет намёка на functional programming и знаменитые hooks, хотя как приём они не исключены, используйте на здоровье, главное - с умом.

 ### Положительные стороны применения
- Высокая скорость рендера
- Возможности прямого управления DOM и, частично, virtual Tree
- Механизм шины событий позволяет организовать обмен данными без flux
- С помощью jet можно быстро создавать всплывающие окна, диалоги, оповещения, и т.п.

### Отрицательные стороны применения
- Сырость механизма патчинга (WIP)
- Необходимость к адаптации кода под требования mustache
- Сложность создания абстрактных компонентов - отсутствует механизм слотирования


## TODO по механике
 - Исправить имплозию компонентов.  
   Теоретически это упущение грозит утечками. При имплозии внутренних частей компонентов нужно не только рекурсивно удалять текущее дерево детей. Нужно также удалить текущий инстанс из виртуального родителя, если таковой имеется.  

 - Сделать что-нибудь с парсингом событий. Минор
   Чтение атрибутов локальных событий компонентом вызывает лёгкое отвращение, хоть и покрывает большинство кейсов.
